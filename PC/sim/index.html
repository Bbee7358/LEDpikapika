<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebSerial Minimal - Connect/Disconnect/Receive/Send</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; color:#e8eef7; font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; }
    #ui { padding: 14px; display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    button {
      padding: 10px 14px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06); color:#e8eef7; cursor:pointer;
    }
    button:disabled { opacity:.45; cursor:not-allowed; }
    #status { opacity:.9; font-size: 13px; }
    #log {
      width: calc(100% - 28px);
      height: calc(100% - 90px);
      margin: 0 14px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.4;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .pill {
      padding: 6px 10px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      font-size: 12px;
      opacity: .9;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="connect">Connect</button>
    <button id="disconnect" disabled>Disconnect</button>

    <!-- 追加：ON/OFF ボタン -->
    <button id="ledOn" disabled>NeoPixel ON</button>
    <button id="ledOff" disabled>NeoPixel OFF</button>

    <!-- 既存：トグル -->
    <button id="toggleLed" disabled>NeoPixel TOGGLE</button>

    <span id="status">serial: OFF</span>
    <span id="ledState" class="pill">LED: ?</span>
  </div>

  <div id="log"></div>

  <script>
    let port = null;

    // read
    let reader = null;
    let textDecoder = null;
    let rxBuf = "";

    // write
    let writer = null;
    let textEncoder = null;

    // --- pipeTo lifecycle (重要) ---
    let readableClosed = null;
    let writableClosed = null;
    let readAbort = null;
    let writeAbort = null;

    // UI
    const $connect = document.getElementById("connect");
    const $disconnect = document.getElementById("disconnect");

    // 追加したボタン
    const $ledOn = document.getElementById("ledOn");
    const $ledOff = document.getElementById("ledOff");

    const $toggleLed = document.getElementById("toggleLed");
    const $status = document.getElementById("status");
    const $ledState = document.getElementById("ledState");
    const $log = document.getElementById("log");

    let enabledGuess = null; // Picoの返答から推定（0/1 or null）

    function setStatus(on){
      $connect.disabled = on;
      $disconnect.disabled = !on;

      // 接続時のみ操作可能にする
      $ledOn.disabled = !on;
      $ledOff.disabled = !on;
      $toggleLed.disabled = !on;

      $status.textContent = on ? "serial: ON" : "serial: OFF";
      if (!on) {
        $ledState.textContent = "LED: ?";
        enabledGuess = null;
      }
    }

    function logLine(s){
      $log.textContent += s + "\n";
      $log.scrollTop = $log.scrollHeight;
    }

    async function writeLine(s){
      if (!writer) throw new Error("writer not ready");
      // MicroPython側は readline() するので \n が必要
      await writer.write(s + "\n");
    }

    async function connect(){
      if (!("serial" in navigator)) {
        alert("WebSerial非対応です。Chromeで開いてください。");
        return;
      }
      if (port) return;

      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 115200 });

      setStatus(true);
      logLine("[connected]");

      // ---- write setup ----
      textEncoder = new TextEncoderStream();
      writeAbort = new AbortController();
      writableClosed = textEncoder.readable.pipeTo(port.writable, { signal: writeAbort.signal });
      writer = textEncoder.writable.getWriter();
      writableClosed.catch(() => {}); // abort/close時にrejectされてもOK

      // ---- read setup ----
      textDecoder = new TextDecoderStream();
      readAbort = new AbortController();
      readableClosed = port.readable.pipeTo(textDecoder.writable, { signal: readAbort.signal });
      reader = textDecoder.readable.getReader();
      readableClosed.catch(() => {});

      (async () => {
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value) onText(value);
          }
        } catch (e) {
          logLine("[read error] " + e.message);
        } finally {
          try { reader?.releaseLock(); } catch {}
          reader = null;
        }
      })();
    }

    function onText(txt){
      rxBuf += txt;
      const lines = rxBuf.split(/\r?\n/);
      rxBuf = lines.pop();
      for (const line of lines) {
        if (!line.length) continue;
        logLine(line);

        // Picoの返答を見てLED状態を推定
        if (line.startsWith("ACK EN 1")) {
          enabledGuess = 1;
        } else if (line.startsWith("ACK EN 0")) {
          enabledGuess = 0;
        } else {
          const m = line.match(/ACK TOGGLE ->\s*(\d)/);
          if (m) enabledGuess = Number(m[1]);
        }

        if (enabledGuess === 1) $ledState.textContent = "LED: ON";
        else if (enabledGuess === 0) $ledState.textContent = "LED: OFF";
        else $ledState.textContent = "LED: ?";
      }
    }

    async function disconnect(){
      if (!port) return;

      logLine("[disconnecting]");

      // 1) 読み取りループを止める
      try { await reader?.cancel(); } catch {}
      try { reader?.releaseLock(); } catch {}
      reader = null;

      // 2) writerを「正常に閉じる」（pipeTo側が終わりやすくなる）
      try { await writer?.close(); } catch {}
      try { writer?.releaseLock(); } catch {}
      writer = null;

      // 3) pipeTo を abort して確実に停止
      try { readAbort?.abort(); } catch {}
      try { writeAbort?.abort(); } catch {}
      readAbort = null;
      writeAbort = null;

      // 4) pipe の終了を待つ（rejectしても握りつぶしてOK）
      try { await readableClosed; } catch {}
      try { await writableClosed; } catch {}
      readableClosed = null;
      writableClosed = null;

      // 5) 最後にポートを閉じる
      try { await port.close(); }
      catch (e) { logLine("[close error] " + (e?.message ?? e)); }

      port = null;
      textDecoder = null;
      textEncoder = null;

      setStatus(false);
      logLine("[disconnected]");
    }

    // UI
    $connect.onclick = async () => {
      try { await connect(); }
      catch (e) { logLine("[connect failed] " + e.message); await disconnect(); }
    };

    $disconnect.onclick = async () => { await disconnect(); };

    // 追加：ON/OFF
    $ledOn.onclick = async () => {
      try {
        await writeLine("EN 1");
        logLine("[tx] EN 1");
      } catch (e) {
        logLine("[tx failed] " + e.message);
      }
    };

    $ledOff.onclick = async () => {
      try {
        await writeLine("EN 0");
        logLine("[tx] EN 0");
      } catch (e) {
        logLine("[tx failed] " + e.message);
      }
    };

    // 既存：TOGGLE
    $toggleLed.onclick = async () => {
      try {
        await writeLine("TOGGLE");
        logLine("[tx] TOGGLE");
      } catch (e) {
        logLine("[tx failed] " + e.message);
      }
    };

    window.addEventListener("beforeunload", () => {
      // こっちは「なるべく綺麗に」落とす（awaitできないので best-effort）
      if (port) {
        try { readAbort?.abort(); } catch {}
        try { writeAbort?.abort(); } catch {}
        try { port.close(); } catch {}
      }
    });

    setStatus(false);
  </script>
</body>
</html>
