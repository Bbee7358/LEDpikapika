<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NeoPixel Board Virtual Space (5 boards, configurable spacing)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; color:#e8eef7; font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      background: rgba(20, 28, 40, 0.92);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 12px;
      width: 560px; max-width: calc(100vw - 24px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      display:flex; gap:10px; flex-wrap: wrap; align-items: center;
    }
    button, input {
      padding: 10px 12px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color:#e8eef7;
      cursor:pointer;
      font-size: 13px;
    }
    button:disabled { opacity:.45; cursor:not-allowed; }
    .group { display:flex; gap:8px; align-items:center; }
    .label { opacity: .85; font-size: 12px; }
    #status { opacity:.9; font-size: 12px; width: 100%; }
    canvas { display:block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="group">
      <button id="btnResetView">RESET VIEW</button>
      <button id="btnClear">CLEAR ALL</button>
      <button id="btnWave">TEST WAVE</button>
    </div>

    <div class="group">
      <span class="label">基板間隔 (mm):</span>
      <input id="inSpacing" type="number" min="0" step="10" value="100" style="width:100px;">
      <button id="btnApplySpacing">適用</button>
    </div>

    <div class="group">
      <span class="label">Selected board:</span>
      <span id="selLabel">none</span>
    </div>

    <div class="group">
      <span class="label">FILL (RGB 0-255):</span>
      <input id="inR" type="number" min="0" max="255" value="20" style="width:72px;">
      <input id="inG" type="number" min="0" max="255" value="0" style="width:72px;">
      <input id="inB" type="number" min="0" max="255" value="0" style="width:72px;">
      <button id="btnFill">FILL 選択基板</button>
    </div>

    <div id="status">Ready</div>
  </div>

  <canvas id="c"></canvas>

<script>
(() => {
  // =============================
  // UI参照（最初に確保）
  // =============================
  const elSel = document.getElementById('selLabel');
  const elStatus = document.getElementById('status');

  function setStatus(s){ elStatus.textContent = s; }

  // 何か例外で止まった時に画面上に出す
  window.addEventListener('error', (e) => {
    setStatus(`JS Error: ${e.message}`);
  });

  // =============================
  // 1) 仕様（48LED/基板直径100mm）
  // =============================
  const BOARD_DIAM_MM = 100;
  const LED_TOTAL = 48;

  // リング仕様（外30/中12/内6）
  const RINGS = [
    { count: 30, diam: 92, startDeg: 0,   indexOffset: 0  },  // 0..29
    { count: 12, diam: 34, startDeg: 15,  indexOffset: 30 },  // 30..41
    { count:  6, diam: 18, startDeg: 0,   indexOffset: 42 },  // 42..47
  ];

  function clamp255(n){
    n = Number(n);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(255, Math.round(n)));
  }

  // =============================
  // 2) Boardデータ（位置は後で反映）
  // =============================
  const boards = [];
  const BOARD_COUNT = 5;

  for (let i = 0; i < BOARD_COUNT; i++) {
    boards.push({
      id: i,
      x: 0,
      y: 0,
      rotDeg: 0,
      ledColors: Array.from({ length: LED_TOTAL }, () => [0, 0, 0]),
    });
  }

  // =============================
  // 3) LEDローカル座標生成（中心(0,0)）
  // =============================
  const ledLocal = (() => {
    const arr = new Array(LED_TOTAL);
    for (const ring of RINGS) {
      const radius = ring.diam / 2;
      for (let k = 0; k < ring.count; k++){
        const deg = ring.startDeg + (360 * k / ring.count);
        const rad = deg * Math.PI / 180;
        const x = Math.cos(rad) * radius;
        const y = Math.sin(rad) * radius;
        arr[ring.indexOffset + k] = { x, y };
      }
    }
    return arr;
  })();

  function rot2d(x, y, deg){
    const a = deg * Math.PI / 180;
    const c = Math.cos(a), s = Math.sin(a);
    return { x: x*c - y*s, y: x*s + y*c };
  }

  // =============================
  // 4) Board間隔反映
  // =============================
  function updateBoardPositions(spacingMm) {
    for (let i = 0; i < boards.length; i++) {
      boards[i].x = i * spacingMm;
      boards[i].y = 0;
    }
    setStatus(`基板間隔を ${spacingMm} mm に設定`);
  }

  // =============================
  // 5) Canvas / Pan & Zoom / Hit test
  // =============================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  const view = {
    scale: 0.55,
    offX: window.innerWidth * 0.15,
    offY: window.innerHeight * 0.55,
  };

  function worldToScreen(wx, wy){
    return { x: wx * view.scale + view.offX, y: wy * view.scale + view.offY };
  }
  function screenToWorld(sx, sy){
    return { x: (sx - view.offX)/view.scale, y: (sy - view.offY)/view.scale };
  }

  let dragging = false;
  let last = {x:0,y:0};

  canvas.addEventListener('mousedown', (e) => {
    dragging = true;
    last = { x: e.clientX, y: e.clientY };
  });
  window.addEventListener('mouseup', () => dragging = false);
  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - last.x;
    const dy = e.clientY - last.y;
    last = { x: e.clientX, y: e.clientY };
    view.offX += dx;
    view.offY += dy;
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const mouse = { x: e.clientX, y: e.clientY };
    const before = screenToWorld(mouse.x, mouse.y);
    const factor = Math.pow(1.0015, -e.deltaY);
    view.scale = Math.max(0.05, Math.min(3.0, view.scale * factor));
    const after = screenToWorld(mouse.x, mouse.y);
    view.offX += (after.x - before.x) * view.scale;
    view.offY += (after.y - before.y) * view.scale;
  }, { passive:false });

  let selectedBoardId = null;

  function hitTestBoard(screenX, screenY){
    const w = screenToWorld(screenX, screenY);
    const r = BOARD_DIAM_MM / 2;

    let best = null;
    let bestD = Infinity;
    for (const b of boards){
      const dx = w.x - b.x;
      const dy = w.y - b.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD) { bestD = d2; best = b; }
    }
    if (!best) return null;
    return (bestD <= r*r) ? best.id : null;
  }

  canvas.addEventListener('click', (e) => {
    const hit = hitTestBoard(e.clientX, e.clientY);
    if (hit !== null) {
      selectedBoardId = hit;
      setStatus(`Selected board = ${hit}`);
    }
  });

  // =============================
  // 6) UIイベント
  // =============================
  document.getElementById('btnResetView').addEventListener('click', () => {
    view.scale = 0.55;
    view.offX = window.innerWidth * 0.15;
    view.offY = window.innerHeight * 0.55;
    setStatus('View reset');
  });

  document.getElementById('btnClear').addEventListener('click', () => {
    for (const b of boards){
      for (let i=0;i<LED_TOTAL;i++) b.ledColors[i] = [0,0,0];
    }
    setStatus('Cleared all LEDs');
  });

  document.getElementById('btnFill').addEventListener('click', () => {
    if (selectedBoardId === null) {
      setStatus('No board selected');
      return;
    }
    const r = clamp255(document.getElementById('inR').value);
    const g = clamp255(document.getElementById('inG').value);
    const b = clamp255(document.getElementById('inB').value);

    const board = boards.find(x => x.id === selectedBoardId);
    for (let i=0;i<LED_TOTAL;i++) board.ledColors[i] = [r,g,b];

    setStatus(`Filled board ${selectedBoardId} rgb=(${r},${g},${b})`);
  });

  document.getElementById('btnApplySpacing').addEventListener('click', () => {
    const v = Number(document.getElementById('inSpacing').value);
    if (!Number.isFinite(v) || v < 0) {
      setStatus('無効な間隔です');
      return;
    }
    updateBoardPositions(v);
  });

  let waveMode = false;
  document.getElementById('btnWave').addEventListener('click', () => {
    waveMode = !waveMode;
    setStatus(waveMode ? 'TEST WAVE: ON' : 'TEST WAVE: OFF');
  });

  // =============================
  // 7) 描画
  // =============================
  function drawGrid(){
    const step = 1000;
    const w0 = screenToWorld(0,0);
    const w1 = screenToWorld(window.innerWidth, window.innerHeight);

    const minX = Math.floor(Math.min(w0.x,w1.x) / step) * step;
    const maxX = Math.ceil(Math.max(w0.x,w1.x) / step) * step;
    const minY = Math.floor(Math.min(w0.y,w1.y) / step) * step;
    const maxY = Math.ceil(Math.max(w0.y,w1.y) / step) * step;

    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath();
    for (let x=minX; x<=maxX; x+=step){
      const a = worldToScreen(x, minY);
      const b = worldToScreen(x, maxY);
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
    }
    for (let y=minY; y<=maxY; y+=step){
      const a = worldToScreen(minX, y);
      const b = worldToScreen(maxX, y);
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
    }
    ctx.stroke();

    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.beginPath();
    {
      const a = worldToScreen(minX, 0);
      const b = worldToScreen(maxX, 0);
      ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
    }
    {
      const a = worldToScreen(0, minY);
      const b = worldToScreen(0, maxY);
      ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
    }
    ctx.stroke();
  }

  function drawBoard(board){
    const c = worldToScreen(board.x, board.y);
    const r = (BOARD_DIAM_MM/2) * view.scale;

    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI*2);
    ctx.fill();

    if (board.id === selectedBoardId){
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(180,220,255,0.70)';
      ctx.beginPath();
      ctx.arc(c.x, c.y, r+2, 0, Math.PI*2);
      ctx.stroke();
    } else {
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.beginPath();
      ctx.arc(c.x, c.y, r, 0, Math.PI*2);
      ctx.stroke();
    }

    const ledRadiusPx = Math.max(1.6, 3.0 * view.scale);
    for (let i=0;i<LED_TOTAL;i++){
      const loc = ledLocal[i];
      const rr = rot2d(loc.x, loc.y, board.rotDeg);
      const w = { x: board.x + rr.x, y: board.y + rr.y };
      const s = worldToScreen(w.x, w.y);

      const [R,G,B] = board.ledColors[i];
      const on = (R|G|B) !== 0;

      ctx.fillStyle = 'rgba(255,255,255,0.10)';
      ctx.beginPath();
      ctx.arc(s.x, s.y, ledRadiusPx+1.2, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = on ? `rgb(${R},${G},${B})` : 'rgba(0,0,0,0.65)';
      ctx.beginPath();
      ctx.arc(s.x, s.y, ledRadiusPx, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.font = '12px system-ui';
    ctx.fillText(`board${board.id}  x=${board.x}mm`, c.x - r, c.y + r + 16);
  }

  // =============================
  // 8) Effect雛形
  // =============================
  function applyTestWave(t){
    for (const bd of boards){
      for (let i=0;i<LED_TOTAL;i++){
        const p = (t*0.001 + bd.id*0.25 + i/LED_TOTAL);
        const r = Math.floor(40 + 40*Math.sin(p*2*Math.PI));
        const g = Math.floor(40 + 40*Math.sin((p+0.33)*2*Math.PI));
        const b = Math.floor(40 + 40*Math.sin((p+0.66)*2*Math.PI));
        bd.ledColors[i] = [r,g,b];
      }
    }
  }

  // =============================
  // 9) 初期配置（ここで呼ぶ！）
  // =============================
  const DEFAULT_SPACING = 100;
  document.getElementById('inSpacing').value = String(DEFAULT_SPACING);
  updateBoardPositions(DEFAULT_SPACING);

  // =============================
  // 10) ループ
  // =============================
  let t0 = performance.now();
  function loop(now){
    const t = now - t0;

    if (waveMode) applyTestWave(t);

    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

    drawGrid();
    for (const bd of boards) drawBoard(bd);

    elSel.textContent = (selectedBoardId === null) ? 'none' : String(selectedBoardId);

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
